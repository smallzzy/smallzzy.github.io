---
layout: post
title: 
date: 2020-05-04 16:00
category: 
author: 
tags: [pwn]
summary: 
---

## crypto

* encrypt-then-MAC

[freq solver](https://quipqiup.com)  
[decode tools](https://www.dcode.fr/tools-list#0)  
[rsactftool](https://github.com/Ganapati/RsaCtfTool)  
[cryptii pipeline](https://cryptii.com/)  

## ssl / tls

* Relies on a existing certificate to verify server identity
  * This certificate can be a weak point in the system
  * Untrustworthy CA -> injected certificate
  * certificate pinning only makes it hard to change the certificate
  * certificate transparency?
* record pre-master key by export `SSLKEYLOGFILE`

[mitmproxy](https://github.com/mitmproxy/mitmproxy)
[sslsplit](https://github.com/droe/sslsplit)

### rsa 

1. client hello
   1. -> client random
2. server hello (encrypt with private key)
   1. <- server random + certificate (pub key)
3. client response
   1. -> pre-master secret (encrypt with pub key)
4. session key generated by client random + server random + secret

### dh

1. client hello
   1. -> client random
2. server hello (encrypt with private key)
   1. <- server random + certificate (pub key)
   2. <- server dh parameter: \\( g^a \\)
3. client response
   1. -> client dh parameter: \\( g^b \\)
   2. generate pre-master secret: \\( g^{ab} \\)
4. session key generated by pre-master secret

[procedure](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/)  
[keyless ssl](https://www.cloudflare.com/learning/ssl/keyless-ssl/)

### forward secrecy

Forward secrecy is achieved if decrypting one session does not expose other sessions.
Usually done by generating different session keys.

rsa does not have fs because pre-master key is encrypted by the same private key.
It can be fixed by using different private key.
But longer rsa key is expensive to generate?

dh has fs because pre-master secret is never exchanged.

## gpg

encrypt the message with public key and decrypt with private key.
so that we know that we are talking to the right person.

* generate key: `--full-generate-key`
* modify keys: `--edit-key <email>`
* save key file: `--output <file> --armor --export <email>`
* save Revocation Certificate: `--output <file> --gen-revoke <email>`
* import key file: `--import <file>`
  * import RC to revoke key

* retrieve key from server: `--keyserver <server> --search-keys <email>`
* send key to server: `--keyserver <server> --send-keys <fingerprint>`
* show fingerprint: `--fingerprint <email>`
  * a short string to verify a received key
* adopt keys: `--sign-key <email>`
* refresh keys: `--refresh-keys`
* key server: `pgp.mit.edu`

* sign file with detached signature file: `--detach-sign`
* sign file with embedded signature (only works with ascii input): `clearsign`
* encrypt and sign file: `--encrypt --sign --recipient <email> <file>`
* decrypt: `--decrypt <file>`

## cipher suite

* RSA
  * PKCS #1
    * n = p * q, p and q are random distinct prime number
    * compute l = least common multiple of p-1 and q-1
    * choose 1 < e < l, where e is co prime to l
    * compute d = modular multiplicative inverse of e wrt l
      * \\( d x e \equiv 1 (mod l) \\)
  * \\( c \equiv m^e (mod n), c^d \equiv m (mod n) \\)
* AES
* Diffie-Hellman (DH)
  * RFC3526: public g and p
  * RFC2412: parameter choosing protocol
  * \\( (g^a mod p)^b mod p = (g^b mod p)^a mod p \\)
* Elliptic Curve Diffie-Hellman (ECDHE)

## cipher mode

* electronic codebook (ECB)
  * same input always become the same output: `https://github.com/EiNSTeiN-/chosen-plaintext`
* cipher block chaining (CBC)
  * during encryption, cipher text is used as input masking for next block
  * padding can leak information on intermediate state
    * PKSC7: pad with # added block
    * \\( I2 = D(C2), P2 = C1 \oplus I2\\)
    * modify C1 such that P2 has a valid padding -> I2
    * knowing C1 and I2, the actual P2 is known
    * `https://robertheaton.com/2013/07/29/padding-oracle-attack/`
    * `https://github.com/mwielgoszewski/python-paddingoracle`
* extended codebook (XCB)

[cipher mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)

## cryptographic hash

Hash based message authentication code (HMAC): RFC 2104

\\[
\begin{align*}
\operatorname{HMAC}(K, m) &= \operatorname{H}\Bigl(\bigl(K' \oplus opad\bigr) \parallel 
  \operatorname{H} \bigl(\left(K' \oplus ipad\right) \parallel m\bigr)\Bigr) \\
K' &= \begin{cases}
  \operatorname{H}\left(K\right) & K\text{ is larger than block size} \\
  K                              & \text{otherwise}
\end{cases}
\end{align*}
\\]

Normal hash functions starts from a known state, 
and results with its internal state.
So, it is easy to modify the message and have the same hash.

SHA 1, 2, 3

https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/validation-search

## PRNG

Mersenne twister
Yarrow
fortuna

https://www.schneier.com/academic/fortuna/

## error correction?

hamming code
Reedâ€“Solomon
Latin Square
convolutional code
ldpc
turbo
polar

## vpn

rustls
ring
boringssl
https://am.i.mullvad.net/
v2ray
shadowsock
wireguard?
