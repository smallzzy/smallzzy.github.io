---
layout: post
title: 
date: 2020-05-04 16:00
category: 
author: 
tags: [pwn]
summary: 
---

## crypto

* encrypt-then-MAC

[freq solver](https://quipqiup.com)  
[decode tools](https://www.dcode.fr/tools-list#0)  
[rsactftool](https://github.com/Ganapati/RsaCtfTool)  
[cryptii pipeline](https://cryptii.com/)  

## ssl / tls

* Relies on a existing certificate to verify server identity
* record pre-master key by export `SSLKEYLOGFILE`

### rsa 

1. client hello
   1. -> client random
2. server hello (encrypt with private key)
   1. <- server random + certificate (pub key)
3. client response
   1. -> pre-master secret (encrypt with pub key)
4. session key generated by client random + server random + secret

### dh

1. client hello
   1. -> client random
2. server hello (encrypt with private key)
   1. <- server random + certificate (pub key)
   2. <- server dh parameter: \\( g^a \\)
3. client response
   1. -> client dh parameter: \\( g^a \\)
   2. generate pre-master secret: \\( g^ab \\)
4. session key generated

[procedure](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/)  
[keyless ssl](https://www.cloudflare.com/learning/ssl/keyless-ssl/)

### forward secrecy

Forward secrecy is achieved if decrypting one session does not expose other sessions.
Usually done by generating different session keys.

rsa does not have fs because pre-master key is encrypted by the same private key.
It can be fixed by using different private key.
But longer rsa key is expensive to generate?

dh has fs because pre-master secret is never exchanged.

## gpg

encrypt the message with public key and decrypt with private key.
so that we know that we are talking to the right person.

key server: `pgp.mit.edu`  
generate key: `--full-generate-key`  
generate key file: `--output <file> --armor --export <email>`  
generate Revocation Certificate: `--output <file> --gen-revoke <email>`  
import key file: `--import <file>`  
show fingerprint: `--fingerprint <email>`, as a method to check keys  
retrieve key from server: `--keyserver <server> --search-keys <email>`  
send key to server: `--keyserver <server> --send-keys <fingerprint>`  
sign keys: `--sign-key <email>`, as a method to adopt keys  
encrypt and sign file: `--encrypt --sign --recipient <email> <file>`  
decrypt: `--decrypt <file>`  
show sign keys: ``  
change trust level: `--edit-key <email>`

## cipher suite

* rsa
* Diffie-Hellman (DH)
  * RFC3526: public g and p
  * RFC2412: parameter choosing protocol
  * \\( (g^a mod p)^b mod p = (g^b mod p)^a mod p \\)
* Elliptic Curve Diffie-Hellman (ECDHE)

## cipher mode

* electronic codebook (ECB)
  * same input always become the same output: `https://github.com/EiNSTeiN-/chosen-plaintext`
* cipher block chaining (CBC)
  * padding can leak information on intermediate state: `https://github.com/mwielgoszewski/python-paddingoracle`
* extended codebook (XCB)

## reference 

[cipher mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)
